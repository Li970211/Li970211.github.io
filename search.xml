<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[myPhoto]]></title>
    <url>%2F2018%2F03%2F25%2FmyPhoto%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[CSS布局解决方案(1)---居中布局]]></title>
    <url>%2F2018%2F03%2F24%2FCSS%E5%B8%83%E5%B1%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1-%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[居中布局水平居中 1. 使用inline-block+text-align （1）原理、用法 原理：先将子框由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 用法：对子框设置display:inline-block，对父框设置text-align:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456 .child&#123; display:inline-block; &#125;.parent&#123; text-align:center; &#125; （3）优缺点 优点:兼容性好，甚至可以兼容ie6、ie7 缺点:child里的文字也会水平居中，可以在.child添加text-align:left;还原 2. 使用table+margin （1）原理、用法 原理：先将子框设置为块级表格来显示（类似 ），再设置子框居中以达到水平居中。 用法：对子框设置display:table，再设置margin:0 auto。 （2）代码实例 123 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.child &#123; display:table; margin:0 auto; &#125; （3）优缺点： 优点：只设置了child，ie8以上都支持 缺点：不支持ie6、ie7,将div换成table 3. 使用absolute+transform （1）原理、用法 原理：将子框设置为绝对定位，移动子框，使子框左侧距离相对框左侧边框的距离为相对框宽度的一半，再通过向左移动子框的一半宽度以达到水平居中。当然，在此之前，我们需要设置父框为相对定位，使父框成为子框的相对框。 用法：对父框设置position:relative，对子框设置position:absolute，left:50%，transform:translateX(-50%)。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child”&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; left:50%; transform:translateX(-50%);&#125; （3）优缺点 优点:居中元素不会对其他的产生影响 缺点:transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 4. 使用flex+margin （1）原理、用法 原理：通过CSS3中的布局利器flex将子框转换为flex item，再设置子框居中以达到居中。 用法：先将父框设置为display:flex，再设置子框margin:0 auto。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456 .parent &#123; display:flex;&#125; .child &#123; margin:0 auto;&#125; （3）优缺点 缺点:低版本浏览器(ie6 ie7 ie8)不支持 5. 使用flex+justify-content （1）原理、用法 原理：通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 用法：先将父框设置为display:flex，再设置justify-content:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; display:flex; justify-content:center;&#125; （3）优缺点 优点:设置parent即可 缺点:低版本浏览器(ie6 ie7 ie8)不支持 垂直居中 1. 使用table-cell+vertical-align （1）原理、用法 原理：通过将父框转化为一个表格单元格显示（类似 和 ），再通过设置属性，使表格单元格内容垂直居中以达到垂直居中。 用法：先将父框设置为display:table-cell，再设置vertical-align:middle。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; display:table-cell; vertical-align:middle;&#125; （3）优缺点 优点:兼容性较好，ie8以上均支持 2. 使用absolute+transform （1）原理、用法 原理：类似于水平居中时的absolute+transform原理。将子框设置为绝对定位，移动子框，使子框上边距离相对框上边边框的距离为相对框高度的一半，再通过向上移动子框的一半高度以达到垂直居中。当然，在此之前，我们需要设置父框为相对定位，使父框成为子框的相对框。 用法：先将父框设置为position:relative，再设置子框position:absolute，top:50%，transform:translateY(-50%)。 （2）代码实例 123 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; top:50%; transform:translateY(-50%);&#125; （3）优缺点 优点:居中元素不会对其他的产生影响 缺点:transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 3. 使用flex+align-items （1）原理、用法 原理：通过设置CSS3中的布局利器flex中的属性align-times，使子框垂直居中。 用法：先将父框设置为position:flex，再设置align-items:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; position:flex; align-items:center;&#125; （3）优缺点 优点:只设置parent 缺点:兼容性存在一定问题 水平垂直居中 1. 使用absolute+transform （1）原理、用法 原理：将水平居中时的absolute+transform和垂直居中时的absolute+transform相结合。详见：水平居中的3）和垂直居中的2）。 见水平居中的3）和垂直居中的2）。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; .parent { position:relative; } .child { position:absolute; left:50%; top:50%; transform:tranplate(-50%,-50%); } （3）优缺点 优点:child元素不会对其他元素产生影响 缺点:兼容性存在一定问题 2. 使用inline-block+text-align+table-cell+vertical-align （1）原理、用法 原理：使用inline-block+text-align水平居中，再用table-cell+vertical-align垂直居中，将二者结合起来。详见：水平居中的1）和垂直居中的1）。 见水平居中的1）和垂直居中的1）。 （2）代码实例 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt; &lt;/div&gt; .parent { text-align:center; display:table-cell; vertical-align:middle; } .child { display:inline-block; } （3）优缺点 优点:兼容性较好3. 使用flex+justify-content+align-items （1）原理、用法 原理：通过设置CSS3布局利器flex中的justify-content和align-items，从而达到水平垂直居中。详见：水平居中的4）和垂直居中的3）。 见水平居中的4）和垂直居中的3）。 （2）代码实例 &lt;div class="parent"&gt; &lt;div class="child&gt;DEMO&lt;/div&gt; &lt;/div&gt; .parent { display:flex; justify-content:center; align-items:center; } （3）优缺点 优点:只设置了parent *缺点:兼容性存在一定问题 文章出处 微信公众号： 前端大牛爱好者http://mp.weixin.qq.com/s/0GPYT4mtOQxh4blJRDGvVQ]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解js中的this]]></title>
    <url>%2F2018%2F03%2F23%2F%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[一.开始 首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象（这句话有些问题，后面会解释为什么会有问题，虽然网上大部分的文章都是这样说的，虽然在很多情况下那样去理解不会出什么问题，但是实际上那样理解是不准确的，所以在你理解this的时候会有种琢磨不透的感觉），那么接下来我会深入的探讨这个问题。 为什么要学习this？如果你学过面向对象编程，那你肯定知道干什么用的，如果你没有学过，那么暂时可以不用看这篇文章，当然如果你有兴趣也可以看看，毕竟这是js中必须要掌握的东西。 二.例子说明例子1： 123456 function a()&#123; var user = "追梦子"; console.log(this.user); //undefined console.log(this); //Window&#125;a(); 按照我们上面说的this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，下面的代码就可以证明。 123456function a()&#123; var user = "追梦子"; console.log(this.user); //undefined console.log(this); //Window&#125;window.a(); 和上面代码一样吧，其实alert也是window的一个属性，也是window点出来的。 例子2： 1234567var o = &#123; user:"追梦子", fn:function()&#123; console.log(this.user); //追梦子 &#125;&#125;o.fn(); 这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o，这里再次强调一点，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁，一定要搞清楚这个。 其实例子1和例子2说的并不够准确，下面这个例子就可以推翻上面的理论。 如果要彻底的搞懂this必须看接下来的几个例子 ###例子3： 1234567var o = &#123; user:"一路", fn:function()&#123; console.log(this.user); //追梦子 &#125;&#125;window.o.fn(); 这段代码和上面的那段代码几乎是一样的，但是这里的this为什么不是指向window，如果按照上面的理论，最终this指向的是调用它的对象，这里先说个而外话，window是js中的全局对象，我们创建的变量实际上是给window添加属性，所以这里可以用window点o对象。 这里先不解释为什么上面的那段代码this为什么没有指向window，我们再来看一段代码。 12345678910var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //12 &#125; &#125;&#125;o.b.fn(); 这里同样也是对象o点出来的，但是同样this并没有执行它，那你肯定会说我一开始说的那些不就都是错误的吗？其实也不是，只是一开始说的不准确，接下来我将补充一句话，我相信你就可以彻底的理解this的指向的问题。 情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。 情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。 情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，例子3可以证明，如果不相信，那么接下来我们继续看几个例子。 12345678910var o = &#123; a:10, b:&#123; // a:12, fn:function()&#123; console.log(this.a); //undefined &#125; &#125;&#125;o.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 ###还有一种比较特殊的情况，例子4： 123456789101112var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //undefined console.log(this); //window &#125; &#125;&#125;var j = o.b.fn;j(); 这里this指向的是window，是不是有些蒙了？其实是因为你没有理解一句话，这句话同样至关重要。 this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这和例子3是不一样的，例子3是直接执行了fn。 this讲来讲去其实就是那么一回事，只不过在不同的情况下指向的会有些不同，上面的总结每个地方都有些小错误，也不能说是错误，而是在不同环境下情况就会有不同，所以我也没有办法一次解释清楚，只能你慢慢地的去体会。 ###构造函数版this： 12345function Fn()&#123; this.user = "追梦子";&#125;var a = new Fn();console.log(a.user); //追梦子 这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，为什么我说a是对象，因为用了new关键字就是创建一个对象实例，理解这句话可以想想我们的例子3，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。 参考阅读 “追梦子”的博客：https://www.cnblogs.com/pssp/p/5216085.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js中的this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则速查表 自己收集了一套针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。 Tips：在本文找想要的正则时，可以尝试使用浏览器的快速查询功能。Ctrl + F输入关键字能提高查询的效率哟~ 常用的正則方法示例 replace: 1234// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.function getLen(str) &#123; return str.replace(/[^\x00-\xff]/g, 'xx').length;&#125; test: 123456789// 匹配是否符合邮件规则var reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// test返回一个布尔值, 表示是否匹配到制定字符串var mail = reg.test('1437690868@qq.com')if (mail) &#123; // 如果邮件格式正确的话, 就可以做点啥了(雾&#125; 常见的表单验证 1234567891011121314151617// 用户名正则，4到16位（字母，数字，下划线，减号）var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;// 匹配邮箱地址var mailReg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// 中国六位数的邮政编码var postalCode = /^\d&#123;6&#125;$/;// 匹配15~18位身份证var IDCard = /(^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;$)/;// 匹配18位的新版身份证var IDCard_18 = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/; 网络相关 1234567891011//ipv4地址正则var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;// Reg Hex颜色正则var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;// URL正则var urlReg= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;// 匹配JSON格式var reg = /^\w+\((&#123;[^()]+&#125;)\)$/ 匹配json字符串 12345678var ret = response.data;if (typeof ret === 'string') &#123; var reg = /^\w+\((&#123;[^()]+&#125;)\)$/ var matches = ret.match(reg); if (matches) ret = JSON.parse(matches[1]);&#125;res.json(ret); 联系方式 1234567891011// 5-11位的腾讯qq号var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;// 国内常见var phone = /^1[3|5|8|9]\d&#123;9&#125;$/;// 固定电话var telephone = /^(0[0-9]&#123;2&#125;)\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\d&#123;7,8&#125;))$/; 匹配特定数字 1234567891011121314151617181920212223242526272829// 匹配正整数var reg = /^[1-9]\d*$/;// 匹配负整数var reg = /^-[1-9]\d*$/;// 匹配整数var reg = /^-?[1-9]\d*$/;// 匹配非负整数（正整数 + 0）var reg = /^[1-9]\d*|0$/;// 匹配非正整数（负整数 + 0）var reg = /^-[1-9]\d*|0$/;// 匹配正浮点数var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/;// 匹配负浮点数var reg = /^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/;// 匹配浮点数var reg = /^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/;// 匹配非负浮点数（正浮点数 + 0）var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/;// 匹配非正浮点数（负浮点数 + 0）var reg = /^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/; 字符串相关 123456789101112131415161718192021222324// 匹配由26个英文字母组成的字符串var reg = /^[A-Za-z]+$/;// 匹配由26个英文字母的大写组成的字符串var reg = /^[A-Z]+$/;// 匹配由26个英文字母的小写组成的字符串var reg = /^[a-z]+$/;// 匹配由数字和26个英文字母组成的字符串var reg = /^[A-Za-z0-9]+$/;// 匹配由数字、26个英文字母或者下;划线组成的字符串var reg = /^\w+$/;// 匹配空白行的正则表达式var reg = /\n\s*\r/;// 匹配首尾空白字符的正则表达式var reg = /^\s*|\s*$/;var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)var reg = /[^\x00-\xff]/g; 正则技巧反向引用 1234// 比如这里我们想让这个日期格式反转// 正则括号是一个分组, 下面的代码就捕获了三个分组// 通过$分组符来转换位置, 来达到我们想要的结果'2018-3-21'.replace(/(\d&#123;4&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)/g, '$2/$3/$1') // "3/21/2018" 忽略分組 不希望捕获某些分组, 只需要分组内加上?:即可: 12var reg = /(?:Byron).(ok)/;'Byron-ok'.replace(reg, '$1'); // 只匹配了 ok 前瞻 名字 正則 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 正向前瞻就是匹配前者, 效验后者是否存在. 1234567// 这个正则的意思是: 匹配一个单词字符( [a-zA-Z0-9_] ), 然后验证后面是不是数字// 结果为: "X2*3". 因为3后面没有数字, 所以没有匹配到.'a2*3'.replace(/\w(?=\d)/g, 'X')// 结果为: "X2*X4X8"// 总的说就是'a2*34v8'.replace(/\w(?=\d)/g, 'X') 负向前瞻则相反, 匹配前面, 替代后面 123456789// a 是单词字符, 后面是数字, 因此没有匹配到// 2 是单词字符, 后面不是数字, 被替换成X// * 不是单词字符 因此没有匹配到// 3 是单词字符, 后面是数字, 因此没有匹配到// 4 是单词字符, 后面不是数字, 被替换成X// v 是单词字符, 后面是数字, 因此没有匹配到// 8 是单词字符, 后面没有匹配到数字, 被替换成X// 结果: aX*4XvX'a2*34v8'.replace(/\w(?!\d)/g, 'X') 最后如果有哪些正则规则有问题的, 可以留言探讨一下呀~ 参考链接： https://github.com/anran758]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js中的正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2018%2F03%2F21%2Fhello%2F</url>
    <content type="text"><![CDATA[大家好！我叫李嘉，来自江西省萍乡市。现就读于华东交通大学软件学院，在以后的日子中要努力学习，用知识武装自己。加油！！！]]></content>
  </entry>
</search>
