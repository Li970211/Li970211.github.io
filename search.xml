<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js类型判断]]></title>
    <url>%2F2018%2F04%2F22%2Fjs%2Fjs%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;类型判断&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type = "text/javascript"&gt; var a = "sndi"; var b = [1,2]; var c = true var d = undefined var e = null var f = 5 var p = function () &#123; console.log(1); &#125; var obj = &#123; name : "li" &#125; // 注意的是，typeof方法返回一个字符串，来表示数据的类型。 //它的返回数据类型有（大写） String ,Boolean ,Undefined Number Function Object //可以具体判断出String，Number,Boolean,Undefined,Function.不能判断Null,和数组和对象 console.log(typeof a,typeof b,typeof c,typeof d,typeof e,typeof f,typeof p,typeof obj); // string object boolean undefined object number function object //instanceof 返回true或者false console.log( b instanceof Array);//true console.log(Array.isArray(b));//判断数组 true console.log( e instanceof Object);//false Javascript规范规定的，Null和Object都是javascript中的数据类型。Null数据类型只有一个值：null。就像undefined数据类型只有一个值：undefine console.log(null == undefined);//true console.log(null === undefined);//false console.log(e === null);//true console.log('--------------------------------------------------'); console.log(Object.prototype.toString.call(a).slice(8,-1)); //返回的是Sting类型，slice是截取了字符串 console.log(Object.prototype.toString.call(b).slice(8,-1)); //返回的是Sting类型，slice是截取了字符串 console.log(Object.prototype.toString.call(c).slice(8,-1)); //返回的是Sting类型，slice是截取了字符串 console.log(Object.prototype.toString.call(d).slice(8,-1)); //返回的是Sting类型，slice是截取了字符串 console.log(Object.prototype.toString.call(e).slice(8,-1)); //返回的是Sting类型，slice是截取了字符串 console.log(Object.prototype.toString.call(f).slice(8,-1)); //返回的是Sting类型，slice是截取了字符串 console.log(Object.prototype.toString.call(p).slice(8,-1)); //返回的是Sting类型，slice是截取了字符串 console.log(Object.prototype.toString.call(obj).slice(8,-1)); //返回的是Sting类型，slice是截取了字符串 //推荐最后这种&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>typepf instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3学习总结(2)---过渡]]></title>
    <url>%2F2018%2F03%2F31%2FCSS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2%2F</url>
    <content type="text"><![CDATA[transition transition是一个简写属性，用于 transition-property,transition-duration,transition-timing-function, 和transition-delay。 CSS 过渡 由简写属性 transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间 默认值： transition-delay: 0s transition-duration: 0s transition-property: all transition-timing-function: ease 下面我们分别介绍一下这些属性 transition-property 用于指定应用过渡属性的名称 1.默认值为 all，表示所有可被动画的属性都表现出过渡动画。(https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties) 可以指定多个 property 2.属性值： none 没有过渡动画。 all 所有可被动画的属性都表现出过渡动画。 IDENT 属性名称 （可以指定多个） 3.代码实例 1&lt;div&gt;&lt;/div&gt; 12345678910111213141516171819&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition-property:width,background; transition-duration:3s;&#125;div:hover &#123; cursor: pointer;//鼠标移入div,形状变成小手 width: 600px; height: 600px; background: deeppink;&#125; 这里transition-property设置了宽width和背景background这两个属性表现出过渡动画，过渡时间是3秒。当鼠标移入div中的时候，div的高会立即变成600px,没有过渡效果。而宽和背景在变化到最终效果都有3s的过渡时间。 transition-duration 1.属性以秒或毫秒为单位指定过渡动画所需的时间。 默认值为 0s ，表示不出现过渡动画。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 2.属性值 以毫秒或秒为单位的数值 类型。表示过渡属性从旧的值转变到新的值所需要的时间。如果时长是 0s ，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。一定要加单位(不能写0 一定要写0s 1s,0s,1s)！ 3.代码实例我们给一个div设置如下样式 12345678910111213141516171819&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition-property:width,height; transition-duration:10s,20s,7s;&#125;div:hover &#123; cursor: pointer; width: 600px; height: 600px;&#125;&lt;/style&gt; 运行结果，当鼠标移入div的时候，由于设置了宽和高设置了过渡效果，但是过渡时间设置了3个时间，那么最后一个时间会被列表裁剪。宽由200px到600px过渡时间10秒，高由200px到600px的过渡时间为20s transition-delay 1.定义：属性规定了在过渡效果开始作用之前需要等待的时间。 默认值：0s 你可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的css属性。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变 2.属性值 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 3.代码实例 12345678910111213141516171819&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition-property:width; transition-duration:5s; transition-delay:2s ;&#125;div:hover &#123; cursor: pointer; width: 600px;&#125;&lt;/style&gt; 运行，当鼠标移入div的时候等待2s之后开始过渡效果。 transition-timing-function1.说明：CSS属性受到 transition的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变2.默认值：ease 你可以规定多个timing function,通过使用 transition-property属性，可以根据主列表(transition property的列表)给每个CSS属性应用相应的timing function.如果timing function的个数比主列表中数量少，缺少的值被设置为初始值（ease） 。如果timing function比主列表要多，timing function函数列表会被截断至合适的大小。这两种情况下声明的CSS属性都是有效的。 3.属性值： 1、ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0). 2、linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0). 3、ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0). 4、ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0). 5、ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) 6、cubic-bezier： 贝塞尔曲线 7、step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(,[,[start|end]]?) 第一个参数：必须为正整数，指定函数的步数 第二个参数：指定每一步的值发生变化的时间点（默认值end） 4.代码实例 12345678910111213141516171819&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition-property:width; transition-duration:5s; transition-timing-function:steps(5,end);&#125;div:hover &#123; cursor: pointer; width: 600px;&#125;&lt;/style&gt; 运行，将鼠标移入div,宽由200到600分成5步进行过渡，渡动时间为5秒。 关于transition过渡属性的简写 1.代码实例 123456789101112131415161718&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition:width 2s linear 4s,height 4s linear 2s;&#125;div:hover &#123; cursor: pointer; width: 600px; height: 600px;&#125; &#125; 上面transition:width 2s linear 4s,height 4s linear 2s;这条样式展开就是如下样式： 1234transition-property: width, height;transition-duration: 2s, 4s;transition-timing-function: linear, linear;transition-delay: 4s, 2s; 当鼠标移入div的时候，等待两秒后，高度先变化，到高度变化2秒后相当于于宽等待了四秒，宽也开始变化。两者都是匀速变化。 最后，要注意当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend, 在 WebKit 下是 webkitTransitionEnd （每一个拥有过渡的属性在其完成过渡时都会触发一次transitionend事件） 在transition完成前设置 display: none，事件同样不会被触发]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3过渡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3学习总结(2)---过渡]]></title>
    <url>%2F2018%2F03%2F31%2FCSS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2FCSS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2%2F</url>
    <content type="text"><![CDATA[transition transition是一个简写属性，用于 transition-property,transition-duration,transition-timing-function, 和transition-delay。 CSS 过渡 由简写属性 transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间 默认值： transition-delay: 0s transition-duration: 0s transition-property: all transition-timing-function: ease 下面我们分别介绍一下这些属性 transition-property 用于指定应用过渡属性的名称 1.默认值为 all，表示所有可被动画的属性都表现出过渡动画。(https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties) 可以指定多个 property 2.属性值： none 没有过渡动画。 all 所有可被动画的属性都表现出过渡动画。 IDENT 属性名称 （可以指定多个） 3.代码实例 1&lt;div&gt;&lt;/div&gt; 12345678910111213141516171819&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition-property:width,background; transition-duration:3s;&#125;div:hover &#123; cursor: pointer;//鼠标移入div,形状变成小手 width: 600px; height: 600px; background: deeppink;&#125; 这里transition-property设置了宽width和背景background这两个属性表现出过渡动画，过渡时间是3秒。当鼠标移入div中的时候，div的高会立即变成600px,没有过渡效果。而宽和背景在变化到最终效果都有3s的过渡时间。 transition-duration 1.属性以秒或毫秒为单位指定过渡动画所需的时间。 默认值为 0s ，表示不出现过渡动画。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 2.属性值 以毫秒或秒为单位的数值 类型。表示过渡属性从旧的值转变到新的值所需要的时间。如果时长是 0s ，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。一定要加单位(不能写0 一定要写0s 1s,0s,1s)！ 3.代码实例我们给一个div设置如下样式 12345678910111213141516171819&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition-property:width,height; transition-duration:10s,20s,7s;&#125;div:hover &#123; cursor: pointer; width: 600px; height: 600px;&#125;&lt;/style&gt; 运行结果，当鼠标移入div的时候，由于设置了宽和高设置了过渡效果，但是过渡时间设置了3个时间，那么最后一个时间会被列表裁剪。宽由200px到600px过渡时间10秒，高由200px到600px的过渡时间为20s transition-delay 1.定义：属性规定了在过渡效果开始作用之前需要等待的时间。 默认值：0s 你可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的css属性。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变 2.属性值 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 3.代码实例 12345678910111213141516171819&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition-property:width; transition-duration:5s; transition-delay:2s ;&#125;div:hover &#123; cursor: pointer; width: 600px;&#125;&lt;/style&gt; 运行，当鼠标移入div的时候等待2s之后开始过渡效果。 transition-timing-function1.说明：CSS属性受到 transition的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变2.默认值：ease 你可以规定多个timing function,通过使用 transition-property属性，可以根据主列表(transition property的列表)给每个CSS属性应用相应的timing function.如果timing function的个数比主列表中数量少，缺少的值被设置为初始值（ease） 。如果timing function比主列表要多，timing function函数列表会被截断至合适的大小。这两种情况下声明的CSS属性都是有效的。 3.属性值： 1、ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0). 2、linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0). 3、ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0). 4、ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0). 5、ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) 6、cubic-bezier： 贝塞尔曲线 7、step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(,[,[start|end]]?) 第一个参数：必须为正整数，指定函数的步数 第二个参数：指定每一步的值发生变化的时间点（默认值end） 4.代码实例 12345678910111213141516171819&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition-property:width; transition-duration:5s; transition-timing-function:steps(5,end);&#125;div:hover &#123; cursor: pointer; width: 600px;&#125;&lt;/style&gt; 运行，将鼠标移入div,宽由200到600分成5步进行过渡，渡动时间为5秒。 关于transition过渡属性的简写 1.代码实例 123456789101112131415161718&lt;style type="text/css"&gt;*&#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 200px; margin: auto; background: pink; transition:width 2s linear 4s,height 4s linear 2s;&#125;div:hover &#123; cursor: pointer; width: 600px; height: 600px;&#125; &#125; 上面transition:width 2s linear 4s,height 4s linear 2s;这条样式展开就是如下样式： 1234transition-property: width, height;transition-duration: 2s, 4s;transition-timing-function: linear, linear;transition-delay: 4s, 2s; 当鼠标移入div的时候，等待两秒后，高度先变化，到高度变化2秒后相当于于宽等待了四秒，宽也开始变化。两者都是匀速变化。 最后，要注意当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend, 在 WebKit 下是 webkitTransitionEnd （每一个拥有过渡的属性在其完成过渡时都会触发一次transitionend事件） 在transition完成前设置 display: none，事件同样不会被触发]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3过渡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3学习总结1]]></title>
    <url>%2F2018%2F03%2F27%2Fcss%2Fcss%2F</url>
    <content type="text"><![CDATA[首先我们先了解什么是CSS? CSS 指层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。浏览器读取css选择器的顺序是从右到左。 CSS3选择器规范地址： https://www.w3.org/TR/2011/REC-css3-selectors-20110929/ CSS3选择最新选择器规范: https://www.w3.org/TR/selectors 分享的这两个网址是CSS3选择器的规范，大家在学习的时候可以看下。 现在让我们一起看一下CSS3中的选择器。 1.基本选择器 通配符选择器 它是*的形式 1* &#123; margin: 0; padding: 0; &#125; 元素选择器 body（任何一个HTML元素） 1body &#123; height:100% &#125; 类选择器 它是.的形式 1&lt;div class = "inner"&gt;inner&lt;/div&gt; 1.class &#123; background:pink &#125; ID选择器 它是#的形式 1&lt;div id = "inner"&gt;inner&lt;/div&gt; 1#id &#123; width:200px;height:200px; &#125; 后代选择器 它是空格的形式,这里是选择所有的后代。 123&lt;div id = "wrap"&gt;wrap &lt;div class = "inner"&gt;inner&lt;/div&gt;&lt;/div&gt; 123#wrap .inner&#123; background:red;&#125; 2.基本选择器扩展 子元素选择器 子元素选择器也可称为直接后代选择器,使用&gt;来选择。注意此类选择器它不同于后代选择器，子元素选择器只是用来选择直接后代，不能匹配到深层次的后代元素. 后代选择器和子选择器区别： 1.写法不一样： 后代选择器的标识为：空格 如：ul li{width:150px;} ul和li之间用空格隔开 子选择器的标识为：&gt; 如：ul&gt;li{width:150px;} ul和li之间用&gt;隔开 2.功能不一样： 后代选择器(descendant selector），又称为包含选择器，可以选择某元素后代的元素，如上例，后代选择器是选择ul包围的所有元素中的所有li元素，包括儿子元素、孙子元素、曾孙元素等等等。 与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素儿子元素的元素，子选择器仅仅选择ul包围的儿子元素中的 li元素，不包括孙元素、曾孙元素等等等。 3.兼容性不一样： 后代选择器主流浏览器都兼容。 子选择器在IE6是不被支持的选择器，会出bug！ 相邻兄弟选择器 使用+来选择。只匹配紧跟着的同胞元素。没有紧跟的兄弟元素匹配不到 123456789&lt;div id="wrap"&gt; &lt;div class="inner"&gt;inner1&lt;/div&gt; &lt;div class="first"&gt;first&lt;/div&gt; &lt;div class="inner"&gt;inner2&lt;/div&gt; &lt;div class="inner"&gt;inner3&lt;/div&gt; &lt;div class="inner"&gt;inner4&lt;/div&gt; &lt;div class="inner"&gt;inner5&lt;/div&gt; &lt;div class="inner"&gt;inner6&lt;/div&gt;&lt;/div&gt; 123#wrap &gt; .first + .inner &#123; color: #f00; &#125; 运行后inner2字体变红，其他不变 通用兄弟选择器 它会匹配所有的兄弟元素(不需要紧跟),在使用 ~ 连接两个元素时,它会匹配第二个元素,条件是: 它必须跟(不一定是紧跟)在第一个元素之后,且他们都有一个共同的父元素 12345678910&lt;div id="wrap"&gt; &lt;div id="first"&gt;first&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;div class="inner"&gt;inner1 &lt;div&gt;inner2&lt;/div&gt; &lt;/div&gt; &lt;div class="inner"&gt;inner3&lt;/div&gt; &lt;div class="inner"&gt;inner4&lt;/div&gt; &lt;div class="inner"&gt;inner5&lt;/div&gt;&lt;/div&gt; 1#wrap #first ~ div &#123; border: 1px solid;&#125; 运行之后我们可以通过控制台查看class为inner都有border: 1px solid这条边框样式，但是inner2这个div没有border: 1px solid这条样式，因为它不是id为first的div的兄弟元素。选择器分组 此处的逗号我们称之为结合符 12345&lt;div&gt; &lt;h1&gt;我是h1&lt;/h1&gt; &lt;h2&gt;我是h2&lt;/h2&gt; &lt;h3&gt;我是h3&lt;/h3&gt;&lt;/div&gt; 1h1,h2,h3&#123;color: pink;&#125; 3.属性选择器 属性选择器是一种特殊类型的选择器，它根据元素的 属性和属性值来匹配元素。它们的通用语法由方括号([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： 存在和值属性选择器和子串值属性选择器。存在和值属性选择器 [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。 12345&lt;div name="hdjtdx_lijia"&gt;李嘉&lt;/div&gt;&lt;div name="hdjtdx_ztj"&gt;张腾金&lt;/div&gt;&lt;div name="hdjtdx_hjl"&gt;何佳林&lt;/div&gt;&lt;div name="hdjtdx_lx"&gt;李旋&lt;/div&gt;&lt;div&gt;一路&lt;/div&gt; 1[name]&#123;color: pink;&#125; 运行只有”一路”字体颜色没有变成粉红色。其他四个div的字体变粉红色。 [attr=val]该选择器仅选择 attr 属性被赋值为 val 的所有元素。 1[name = "hdjtdx_lijia"]&#123;color: pink;&#125; 以上面的例子为例，此时运行只有”李嘉”字体颜色变成粉红色 [attr~=val]：表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为val。 12345&lt;div name="hdjtdx_lijia hdjtdx"&gt;李嘉&lt;/div&gt;&lt;div name="hdjtdx_ztj"&gt;张腾金&lt;/div&gt;&lt;div name="hdjtdx_hjl hdjtdx yichun"&gt;何佳林&lt;/div&gt;&lt;div name="hdjtdx_lx"&gt;李旋&lt;/div&gt;&lt;div&gt;一路&lt;/div&gt; 1[name ~= "hdjtdx"]&#123;color: pink;&#125; 运行”李嘉”和”何佳林”变成粉红色的，其他的不变。 4.子串值属性选择器 这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似 regular expression 的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）： [attr|=val] : 选择attr属性的值是val（包括val）或以val-开头的元素。 [attr^=val] : 选择attr属性的值以val开头（包括val）的元素。 [attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。 [attr*=val] : 选择attr属性的值中包含字符串val的元素。 12345&lt;div name="hdjtdx_lijia hdjtdx"&gt;李嘉&lt;/div&gt;&lt;div name="hdjtdx-ztj"&gt;张腾金&lt;/div&gt;&lt;div name="hdjtdx_hjl hdjtdx"&gt;何佳林&lt;/div&gt;&lt;div name="hdjtdx_lx"&gt;李旋&lt;/div&gt;&lt;div name="yilu-hdjtdx"&gt;一路&lt;/div&gt; 123[name|="hdjtdx"]&#123; color: pink;&#125; 运行后”张腾金”字体变成粉红色字体，其他的不变。 123 [name^="hdjtdx"]&#123;color: pink; &#125; 运行后只有”一路”字体不变，因为它的name属性不是以hdjtdx开头的元素。其他四个div里面的字体颜色都变成粉红色。 123[name$="hdjtdx"]&#123; color: pink;&#125; 运行后”李嘉”,”何佳林”和”一路”字体变成粉红色，因为它的name属性是以hdjtdx结尾的元素。 123[name*="z"]&#123; color: pink;&#125; 运行后只有”张腾金”字体变成粉红色，因为它的name属性的值包含字符串”z”的元素 5.伪类与伪元素选择器 什么是伪类呢？简单点说，就是你没定义这个类，但它确实作为一个类来使用。（这些类确实存在，浏览器在后台会向这些类增加和删除元素）链接伪类 :link 表示作为超链接，并指向一个未访问的地址的所有锚 :visited 表示作为超链接，并指向一个已访问的地址的所有锚 :target 代表一个特殊的元素，它的id是URI的片段标识符 注意:link，:visited，:target是作用于链接元素的！动态伪类 :hover 表示悬浮到元素上 :active 表示匹配被用户激活的元素（点击按住时） 注意:hover，:active基本可以作用于所有的元素！ 隐私与:visited选择器 只有下列的属性才能被应用到已访问链接： color background-color border-color a链接的四个伪类的书写顺序一定要正确，否则浏览器可能不会显示预期的结果。也即这样写： 1 a:link{color:black;} 2 a:visited{color:gray;} 3 a:hover{color:red;} 4 a:active{color:blue;} 首先注意关键的两点： 1.这4个伪类特指度相同。 2.一个链接可能同时处于多种状态，即同时属于多个伪类。 未点击链接前，link伪类长期处于激活状态，鼠标悬停（或点击）时，a链接同时处于link和hover(或active)状态，由于它们特指度相同，在同时激活的情况下，后出现的伪类样式会覆盖前面的伪类样式，故link状态必须写在hover(或active)之前。 再讨论hover和active的顺序，若把hover放在active后面，当点击链接一瞬，实际你在激活active状态的同时触发了hover伪类,hover在后面覆盖了active的颜色，所以无法看到active的颜色。故hover在active之前 其次，若把visited放在hover后面，那已访问过的链接一直触发着visited伪类，会覆盖hover样式。 最后，其实link、visited两个伪类之间顺序无所谓。（因为它俩不可能同时触发，即又未访问同时又已访问。） 记这顺序有个小招数，“LoVe？ HA!”。 此处参考地址：http://www.cnblogs.com/xiayi/ 表单相关伪类 :enabled 匹配可编辑的表单 :disable 匹配被禁用的表单 :checked 匹配被选中的表单 :focus 匹配获焦的表单 结构性伪类 index的值从1开始计数！！！！ index可以为变量n(只能是n) index可以为even odd #wrap ele:nth-child(index) 表示匹配#wrap中第index的子元素 这个子元素必须是ele #wrap ele:nth-of-type(index) 表示匹配#wrap中第index的ele子元素 除此之外:nth-child和:nth-of-type有一个很重要的区别！！ nth-of-type以元素为中心！！！ :nth-child(index)系列 :first-child :last-child :nth-last-child(index) :only-child (相对于:first-child:last-child 或者 :nth-child(1):nth-last-child(1)) :nth-of-type(index)系列 :first-of-type :last-of-type :nth-last-type(index) :only-of-type (相对于:first-of-type:last-of-type 或者 :nth-of-type(1):nth-last-of-type(1)) :nth-child和:nth-of-type这两个系列的用法和区别我就不详细分析了。大家可以参考：https://blog.csdn.net/liuyan19891230/article/details/52839788 :not 否定伪类，用于匹配不符合参数选择器的元素； :empty 配没有子元素的元素。如果元素中含有文本节点、HTML元素或者一个空格，则:empty不能匹配这个元素；(内容必须是空的，有空格都不行，有attr没关系)伪元素 ::before/:before 在某个元素之前插入一些内容； ::after/:after 在某个元素之后插入一些内容； ::first-letter/:first-letter 为某个元素中的文字的首字母或第一个字使用样式； ::first-line/:first-line 为某个元素的第一行文字使用样式； ::selection 匹配用户被用户选中或者处于高亮状态的部分 注：上面并没有把CSS3里面的所有选择器列出来，只总结了一些比较常用的选择器。由于小弟我水平有限，难免有不足之处，希望各位大佬多多指点。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myPhoto]]></title>
    <url>%2F2018%2F03%2F25%2FmyPhoto%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS布局解决方案(1)---居中布局]]></title>
    <url>%2F2018%2F03%2F24%2FCSS%E5%B8%83%E5%B1%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1-%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[居中布局水平居中 1. 使用inline-block+text-align （1）原理、用法 原理：先将子框由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 用法：对子框设置display:inline-block，对父框设置text-align:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456 .child&#123; display:inline-block; &#125;.parent&#123; text-align:center; &#125; （3）优缺点 优点:兼容性好，甚至可以兼容ie6、ie7 缺点:child里的文字也会水平居中，可以在.child添加text-align:left;还原 2. 使用table+margin （1）原理、用法 原理：先将子框设置为块级表格来显示（类似 ），再设置子框居中以达到水平居中。 用法：对子框设置display:table，再设置margin:0 auto。 （2）代码实例 123 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.child &#123; display:table; margin:0 auto; &#125; （3）优缺点： 优点：只设置了child，ie8以上都支持 缺点：不支持ie6、ie7,将div换成table 3. 使用absolute+transform （1）原理、用法 原理：将子框设置为绝对定位，移动子框，使子框左侧距离相对框左侧边框的距离为相对框宽度的一半，再通过向左移动子框的一半宽度以达到水平居中。当然，在此之前，我们需要设置父框为相对定位，使父框成为子框的相对框。 用法：对父框设置position:relative，对子框设置position:absolute，left:50%，transform:translateX(-50%)。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child”&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; left:50%; transform:translateX(-50%);&#125; （3）优缺点 优点:居中元素不会对其他的产生影响 缺点:transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 4. 使用flex+margin （1）原理、用法 原理：通过CSS3中的布局利器flex将子框转换为flex item，再设置子框居中以达到居中。 用法：先将父框设置为display:flex，再设置子框margin:0 auto。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456 .parent &#123; display:flex;&#125; .child &#123; margin:0 auto;&#125; （3）优缺点 缺点:低版本浏览器(ie6 ie7 ie8)不支持 5. 使用flex+justify-content （1）原理、用法 原理：通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 用法：先将父框设置为display:flex，再设置justify-content:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; display:flex; justify-content:center;&#125; （3）优缺点 优点:设置parent即可 缺点:低版本浏览器(ie6 ie7 ie8)不支持 垂直居中 1. 使用table-cell+vertical-align （1）原理、用法 原理：通过将父框转化为一个表格单元格显示（类似 和 ），再通过设置属性，使表格单元格内容垂直居中以达到垂直居中。 用法：先将父框设置为display:table-cell，再设置vertical-align:middle。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; display:table-cell; vertical-align:middle;&#125; （3）优缺点 优点:兼容性较好，ie8以上均支持 2. 使用absolute+transform （1）原理、用法 原理：类似于水平居中时的absolute+transform原理。将子框设置为绝对定位，移动子框，使子框上边距离相对框上边边框的距离为相对框高度的一半，再通过向上移动子框的一半高度以达到垂直居中。当然，在此之前，我们需要设置父框为相对定位，使父框成为子框的相对框。 用法：先将父框设置为position:relative，再设置子框position:absolute，top:50%，transform:translateY(-50%)。 （2）代码实例 123 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; top:50%; transform:translateY(-50%);&#125; （3）优缺点 优点:居中元素不会对其他的产生影响 缺点:transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 3. 使用flex+align-items （1）原理、用法 原理：通过设置CSS3中的布局利器flex中的属性align-times，使子框垂直居中。 用法：先将父框设置为position:flex，再设置align-items:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; position:flex; align-items:center;&#125; （3）优缺点 优点:只设置parent 缺点:兼容性存在一定问题 水平垂直居中 1. 使用absolute+transform （1）原理、用法 原理：将水平居中时的absolute+transform和垂直居中时的absolute+transform相结合。详见：水平居中的3）和垂直居中的2）。 见水平居中的3）和垂直居中的2）。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; .parent { position:relative; } .child { position:absolute; left:50%; top:50%; transform:tranplate(-50%,-50%); } （3）优缺点 优点:child元素不会对其他元素产生影响 缺点:兼容性存在一定问题 2. 使用inline-block+text-align+table-cell+vertical-align （1）原理、用法 原理：使用inline-block+text-align水平居中，再用table-cell+vertical-align垂直居中，将二者结合起来。详见：水平居中的1）和垂直居中的1）。 见水平居中的1）和垂直居中的1）。 （2）代码实例 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt; &lt;/div&gt; .parent { text-align:center; display:table-cell; vertical-align:middle; } .child { display:inline-block; } （3）优缺点 优点:兼容性较好3. 使用flex+justify-content+align-items （1）原理、用法 原理：通过设置CSS3布局利器flex中的justify-content和align-items，从而达到水平垂直居中。详见：水平居中的4）和垂直居中的3）。 见水平居中的4）和垂直居中的3）。 （2）代码实例 &lt;div class="parent"&gt; &lt;div class="child&gt;DEMO&lt;/div&gt; &lt;/div&gt; .parent { display:flex; justify-content:center; align-items:center; } （3）优缺点 优点:只设置了parent *缺点:兼容性存在一定问题 文章出处 微信公众号： 前端大牛爱好者http://mp.weixin.qq.com/s/0GPYT4mtOQxh4blJRDGvVQ]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局解决方案(1)---居中布局]]></title>
    <url>%2F2018%2F03%2F24%2FCSS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2FCSS%E5%B8%83%E5%B1%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1-%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[居中布局水平居中 1. 使用inline-block+text-align （1）原理、用法 原理：先将子框由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 用法：对子框设置display:inline-block，对父框设置text-align:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456 .child&#123; display:inline-block; &#125;.parent&#123; text-align:center; &#125; （3）优缺点 优点:兼容性好，甚至可以兼容ie6、ie7 缺点:child里的文字也会水平居中，可以在.child添加text-align:left;还原 2. 使用table+margin （1）原理、用法 原理：先将子框设置为块级表格来显示（类似 ），再设置子框居中以达到水平居中。 用法：对子框设置display:table，再设置margin:0 auto。 （2）代码实例 123 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.child &#123; display:table; margin:0 auto; &#125; （3）优缺点： 优点：只设置了child，ie8以上都支持 缺点：不支持ie6、ie7,将div换成table 3. 使用absolute+transform （1）原理、用法 原理：将子框设置为绝对定位，移动子框，使子框左侧距离相对框左侧边框的距离为相对框宽度的一半，再通过向左移动子框的一半宽度以达到水平居中。当然，在此之前，我们需要设置父框为相对定位，使父框成为子框的相对框。 用法：对父框设置position:relative，对子框设置position:absolute，left:50%，transform:translateX(-50%)。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child”&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; left:50%; transform:translateX(-50%);&#125; （3）优缺点 优点:居中元素不会对其他的产生影响 缺点:transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 4. 使用flex+margin （1）原理、用法 原理：通过CSS3中的布局利器flex将子框转换为flex item，再设置子框居中以达到居中。 用法：先将父框设置为display:flex，再设置子框margin:0 auto。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456 .parent &#123; display:flex;&#125; .child &#123; margin:0 auto;&#125; （3）优缺点 缺点:低版本浏览器(ie6 ie7 ie8)不支持 5. 使用flex+justify-content （1）原理、用法 原理：通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 用法：先将父框设置为display:flex，再设置justify-content:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; display:flex; justify-content:center;&#125; （3）优缺点 优点:设置parent即可 缺点:低版本浏览器(ie6 ie7 ie8)不支持 垂直居中 1. 使用table-cell+vertical-align （1）原理、用法 原理：通过将父框转化为一个表格单元格显示（类似 和 ），再通过设置属性，使表格单元格内容垂直居中以达到垂直居中。 用法：先将父框设置为display:table-cell，再设置vertical-align:middle。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; display:table-cell; vertical-align:middle;&#125; （3）优缺点 优点:兼容性较好，ie8以上均支持 2. 使用absolute+transform （1）原理、用法 原理：类似于水平居中时的absolute+transform原理。将子框设置为绝对定位，移动子框，使子框上边距离相对框上边边框的距离为相对框高度的一半，再通过向上移动子框的一半高度以达到垂直居中。当然，在此之前，我们需要设置父框为相对定位，使父框成为子框的相对框。 用法：先将父框设置为position:relative，再设置子框position:absolute，top:50%，transform:translateY(-50%)。 （2）代码实例 123 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; top:50%; transform:translateY(-50%);&#125; （3）优缺点 优点:居中元素不会对其他的产生影响 缺点:transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 3. 使用flex+align-items （1）原理、用法 原理：通过设置CSS3中的布局利器flex中的属性align-times，使子框垂直居中。 用法：先将父框设置为position:flex，再设置align-items:center。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; position:flex; align-items:center;&#125; （3）优缺点 优点:只设置parent 缺点:兼容性存在一定问题 水平垂直居中 1. 使用absolute+transform （1）原理、用法 原理：将水平居中时的absolute+transform和垂直居中时的absolute+transform相结合。详见：水平居中的3）和垂直居中的2）。 见水平居中的3）和垂直居中的2）。 （2）代码实例 123&lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt;&lt;/div&gt; .parent { position:relative; } .child { position:absolute; left:50%; top:50%; transform:tranplate(-50%,-50%); } （3）优缺点 优点:child元素不会对其他元素产生影响 缺点:兼容性存在一定问题 2. 使用inline-block+text-align+table-cell+vertical-align （1）原理、用法 原理：使用inline-block+text-align水平居中，再用table-cell+vertical-align垂直居中，将二者结合起来。详见：水平居中的1）和垂直居中的1）。 见水平居中的1）和垂直居中的1）。 （2）代码实例 &lt;div class="parent"&gt; &lt;div class="child"&gt;DEMO&lt;/div&gt; &lt;/div&gt; .parent { text-align:center; display:table-cell; vertical-align:middle; } .child { display:inline-block; } （3）优缺点 优点:兼容性较好3. 使用flex+justify-content+align-items （1）原理、用法 原理：通过设置CSS3布局利器flex中的justify-content和align-items，从而达到水平垂直居中。详见：水平居中的4）和垂直居中的3）。 见水平居中的4）和垂直居中的3）。 （2）代码实例 &lt;div class="parent"&gt; &lt;div class="child&gt;DEMO&lt;/div&gt; &lt;/div&gt; .parent { display:flex; justify-content:center; align-items:center; } （3）优缺点 优点:只设置了parent *缺点:兼容性存在一定问题 文章出处 微信公众号： 前端大牛爱好者http://mp.weixin.qq.com/s/0GPYT4mtOQxh4blJRDGvVQ]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解js中的this]]></title>
    <url>%2F2018%2F03%2F23%2Fjs%2F%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[一.开始 首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象（这句话有些问题，后面会解释为什么会有问题，虽然网上大部分的文章都是这样说的，虽然在很多情况下那样去理解不会出什么问题，但是实际上那样理解是不准确的，所以在你理解this的时候会有种琢磨不透的感觉），那么接下来我会深入的探讨这个问题。 为什么要学习this？如果你学过面向对象编程，那你肯定知道干什么用的，如果你没有学过，那么暂时可以不用看这篇文章，当然如果你有兴趣也可以看看，毕竟这是js中必须要掌握的东西。 二.例子说明例子1： 123456 function a()&#123; var user = "追梦子"; console.log(this.user); //undefined console.log(this); //Window&#125;a(); 按照我们上面说的this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，下面的代码就可以证明。 123456function a()&#123; var user = "追梦子"; console.log(this.user); //undefined console.log(this); //Window&#125;window.a(); 和上面代码一样吧，其实alert也是window的一个属性，也是window点出来的。 例子2： 1234567var o = &#123; user:"追梦子", fn:function()&#123; console.log(this.user); //追梦子 &#125;&#125;o.fn(); 这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o，这里再次强调一点，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁，一定要搞清楚这个。 其实例子1和例子2说的并不够准确，下面这个例子就可以推翻上面的理论。 如果要彻底的搞懂this必须看接下来的几个例子 例子3： 1234567var o = &#123; user:"一路", fn:function()&#123; console.log(this.user); //追梦子 &#125;&#125;window.o.fn(); 这段代码和上面的那段代码几乎是一样的，但是这里的this为什么不是指向window，如果按照上面的理论，最终this指向的是调用它的对象，这里先说个而外话，window是js中的全局对象，我们创建的变量实际上是给window添加属性，所以这里可以用window点o对象。 这里先不解释为什么上面的那段代码this为什么没有指向window，我们再来看一段代码。 12345678910var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //12 &#125; &#125;&#125;o.b.fn(); 这里同样也是对象o点出来的，但是同样this并没有执行它，那你肯定会说我一开始说的那些不就都是错误的吗？其实也不是，只是一开始说的不准确，接下来我将补充一句话，我相信你就可以彻底的理解this的指向的问题。 情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。 情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。 情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，例子3可以证明，如果不相信，那么接下来我们继续看几个例子。 12345678910var o = &#123; a:10, b:&#123; // a:12, fn:function()&#123; console.log(this.a); //undefined &#125; &#125;&#125;o.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 ###还有一种比较特殊的情况，例子4： 123456789101112var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //undefined console.log(this); //window &#125; &#125;&#125;var j = o.b.fn;j(); 这里this指向的是window，是不是有些蒙了？其实是因为你没有理解一句话，这句话同样至关重要。 this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这和例子3是不一样的，例子3是直接执行了fn。 this讲来讲去其实就是那么一回事，只不过在不同的情况下指向的会有些不同，上面的总结每个地方都有些小错误，也不能说是错误，而是在不同环境下情况就会有不同，所以我也没有办法一次解释清楚，只能你慢慢地的去体会。 ###构造函数版this： 12345function Fn()&#123; this.user = "追梦子";&#125;var a = new Fn();console.log(a.user); //追梦子 这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，为什么我说a是对象，因为用了new关键字就是创建一个对象实例，理解这句话可以想想我们的例子3，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。 参考阅读 “追梦子”的博客：https://www.cnblogs.com/pssp/p/5216085.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js中的this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F03%2F22%2Fjs%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则速查表 自己收集了一套针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。 Tips：在本文找想要的正则时，可以尝试使用浏览器的快速查询功能。Ctrl + F输入关键字能提高查询的效率哟~ 常用的正則方法示例 replace: 1234// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.function getLen(str) &#123; return str.replace(/[^\x00-\xff]/g, 'xx').length;&#125; test: 123456789// 匹配是否符合邮件规则var reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// test返回一个布尔值, 表示是否匹配到制定字符串var mail = reg.test('1437690868@qq.com')if (mail) &#123; // 如果邮件格式正确的话, 就可以做点啥了(雾&#125; 常见的表单验证 1234567891011121314151617// 用户名正则，4到16位（字母，数字，下划线，减号）var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;// 匹配邮箱地址var mailReg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// 中国六位数的邮政编码var postalCode = /^\d&#123;6&#125;$/;// 匹配15~18位身份证var IDCard = /(^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;$)/;// 匹配18位的新版身份证var IDCard_18 = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/; 网络相关 1234567891011//ipv4地址正则var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;// Reg Hex颜色正则var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;// URL正则var urlReg= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;// 匹配JSON格式var reg = /^\w+\((&#123;[^()]+&#125;)\)$/ 匹配json字符串 12345678var ret = response.data;if (typeof ret === 'string') &#123; var reg = /^\w+\((&#123;[^()]+&#125;)\)$/ var matches = ret.match(reg); if (matches) ret = JSON.parse(matches[1]);&#125;res.json(ret); 联系方式 1234567891011// 5-11位的腾讯qq号var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;// 国内常见var phone = /^1[3|5|8|9]\d&#123;9&#125;$/;// 固定电话var telephone = /^(0[0-9]&#123;2&#125;)\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\d&#123;7,8&#125;))$/; 匹配特定数字 1234567891011121314151617181920212223242526272829// 匹配正整数var reg = /^[1-9]\d*$/;// 匹配负整数var reg = /^-[1-9]\d*$/;// 匹配整数var reg = /^-?[1-9]\d*$/;// 匹配非负整数（正整数 + 0）var reg = /^[1-9]\d*|0$/;// 匹配非正整数（负整数 + 0）var reg = /^-[1-9]\d*|0$/;// 匹配正浮点数var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/;// 匹配负浮点数var reg = /^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/;// 匹配浮点数var reg = /^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/;// 匹配非负浮点数（正浮点数 + 0）var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/;// 匹配非正浮点数（负浮点数 + 0）var reg = /^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/; 字符串相关 123456789101112131415161718192021222324// 匹配由26个英文字母组成的字符串var reg = /^[A-Za-z]+$/;// 匹配由26个英文字母的大写组成的字符串var reg = /^[A-Z]+$/;// 匹配由26个英文字母的小写组成的字符串var reg = /^[a-z]+$/;// 匹配由数字和26个英文字母组成的字符串var reg = /^[A-Za-z0-9]+$/;// 匹配由数字、26个英文字母或者下;划线组成的字符串var reg = /^\w+$/;// 匹配空白行的正则表达式var reg = /\n\s*\r/;// 匹配首尾空白字符的正则表达式var reg = /^\s*|\s*$/;var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)var reg = /[^\x00-\xff]/g; 正则技巧反向引用 1234// 比如这里我们想让这个日期格式反转// 正则括号是一个分组, 下面的代码就捕获了三个分组// 通过$分组符来转换位置, 来达到我们想要的结果'2018-3-21'.replace(/(\d&#123;4&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)/g, '$2/$3/$1') // "3/21/2018" 忽略分組 不希望捕获某些分组, 只需要分组内加上?:即可: 12var reg = /(?:Byron).(ok)/;'Byron-ok'.replace(reg, '$1'); // 只匹配了 ok 前瞻 名字 正則 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 正向前瞻就是匹配前者, 效验后者是否存在. 1234567// 这个正则的意思是: 匹配一个单词字符( [a-zA-Z0-9_] ), 然后验证后面是不是数字// 结果为: "X2*3". 因为3后面没有数字, 所以没有匹配到.'a2*3'.replace(/\w(?=\d)/g, 'X')// 结果为: "X2*X4X8"// 总的说就是'a2*34v8'.replace(/\w(?=\d)/g, 'X') 负向前瞻则相反, 匹配前面, 替代后面 123456789// a 是单词字符, 后面是数字, 因此没有匹配到// 2 是单词字符, 后面不是数字, 被替换成X// * 不是单词字符 因此没有匹配到// 3 是单词字符, 后面是数字, 因此没有匹配到// 4 是单词字符, 后面不是数字, 被替换成X// v 是单词字符, 后面是数字, 因此没有匹配到// 8 是单词字符, 后面没有匹配到数字, 被替换成X// 结果: aX*4XvX'a2*34v8'.replace(/\w(?!\d)/g, 'X') 最后如果有哪些正则规则有问题的, 可以留言探讨一下呀~ 参考链接： https://github.com/anran758]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js中的正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2018%2F03%2F21%2Fhello%2F</url>
    <content type="text"><![CDATA[大家好！我叫李嘉，来自江西省萍乡市。现就读于华东交通大学软件学院，在以后的日子中要努力学习，用知识武装自己。加油！！！]]></content>
  </entry>
</search>
